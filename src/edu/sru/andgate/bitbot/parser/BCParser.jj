/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. BCParser.jj */
/*@egen*//**
 * JJTree template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 */
options
{
  JDK_VERSION = "1.5";
  IGNORE_CASE = true;
  STATIC = false;
                         
                 
                
}
 
PARSER_BEGIN(bc1)
package edu.sru.andgate.bitbot.parser;

public class bc1/*@bgen(jjtree)*/implements bc1TreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTbc1State jjtree = new JJTbc1State();

/*@egen*/}
PARSER_END(bc1)

/* Skip Whitespace & comments */
SKIP :
{
  " "
| "\t"
//| "\n"//| "\r"
| < "//" (~[ "\n", "\r" ])*
    (
      "\n"
    | "\r"
    | "\r\n"
    ) >
| < "/*" (~[ "*" ])* "*"
    (
      ~[ "/" ] (~[ "*" ])* "*"
    )*
    "/" >
}

TOKEN : /* LITERALS */
{
  < INTEGER_LITERAL :
    < DECIMAL_LITERAL > ([ "l", "L" ])?
  | < HEX_LITERAL > ([ "l", "L" ])?
  | < OCTAL_LITERAL > ([ "l", "L" ])? 
    >
| < #DECIMAL_LITERAL : [ "1"-"9" ] ([ "0"-"9" ])* >
| < #HEX_LITERAL : "0" [ "x", "X" ] ([ "0"-"9", "a"-"f", "A"-"F" ])+ >
| < #OCTAL_LITERAL : "0" ([ "0"-"7" ])* >
}

TOKEN : /* OPERATIONS */
{
  < BOOL_OP : "AND" | "OR" >
| < EQ_OP : "==" | "!=" >
| < REL_OP : "<" | ">" | "<=" | ">=" > 
| < ADD_OP : "+" | "-" >
| < MUL_OP : "*" | "/" | "%" >
//| < POW_OP : "^" >
| < CONCAT : "&" >
}

TOKEN : /* RESERVED WORDS */
{
  < NL : ("\n" | "\r" | "\r\n") >  // Statement Terminator

| < PRINT : "print" >
| < LET : "let" >
| < EQUAL : "=" | "eq" >
| < DIM : "dim" >
| < AS : "as" >

| < WHILE : "while" >
| < DO : "do" >
| < LOOP : "loop" >

| < FOR : "for" >
| < TO : "to" >
| < STEP : "step" >
| < NEXT : "next" >

| < IF : "if" >
| < THEN : "then" >
| < ELSE : "else" >
| < ENDIF : "endif" >

| < INTEGER : "integer" >
| < DOUBLE : "double" >
| < STRING : "string" >
| < ARRAY : "array" >
| < PROGRAM : "program" >
| < SUBROUTINE : "subroutine" | "sub" >
| < CALL: "call">
| < END: "end" >
| < RETURN: "return" >
}

TOKEN : /* IDENTIFIERS */
{
  < IDENTIFIER :
    < LETTER >
    (
      < LETTER >
    | < DIGIT >
    )* >
| < #LETTER : [ "_", "a"-"z", "A"-"Z" ] >
| < #DIGIT : [ "0"-"9" ] >
| < STRING_LITERAL : "\"" (~["\""])* "\"" >
}

SimpleNode Start()       :
{/*@bgen(jjtree) Root */
  ASTRoot jjtn000 = new ASTRoot(JJTROOT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Root */
  try {
/*@egen*/
  Program()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    return jjtn000;
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Program() :
{/*@bgen(jjtree) Program */
  ASTProgram jjtn000 = new ASTProgram(JJTPROGRAM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Program */
  try {
/*@egen*/
  (
    < PROGRAM > Identifier() 
  )?
  
  ListOfInstructions()
  
  (
    < END >
    
    ( < NL > )+
    
    // Subroutines
    (
      SubDef()
      ( < NL > )+
    )*
  )?
  
  < EOF >/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void ListOfInstructions() :
{/*@bgen(jjtree) ListOfInstructions */
  ASTListOfInstructions jjtn000 = new ASTListOfInstructions(JJTLISTOFINSTRUCTIONS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ListOfInstructions */
  try {
/*@egen*/
  (
    Instruction()
    ( < NL > )+
  )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Instruction()       :
{}
{
  Expression()  //";"
  |
  Assignment() //";"
  | 
  Print() //";"
  |
  Declaration() //";"
  |
  SubCall() //";" 
  |
  WhileLoop()
  |
  IfStatement()
  |
  ForLoop()
}

void WhileLoop() :
{/*@bgen(jjtree) WhileLoop */
  ASTWhileLoop jjtn000 = new ASTWhileLoop(JJTWHILELOOP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) WhileLoop */
  try {
/*@egen*/
  < WHILE > Expression() < DO > <NL> ListOfInstructions() < LOOP >/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void IfStatement() :
{/*@bgen(jjtree) IfStatement */
  ASTIfStatement jjtn000 = new ASTIfStatement(JJTIFSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) IfStatement */
  try {
/*@egen*/
  < IF > Expression() < THEN > < NL >
  
  ListOfInstructions()
  ( < ELSE > < NL >
    ListOfInstructions()
  )?
  
  < ENDIF >/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void ForLoop() :
{/*@bgen(jjtree) ForLoop */
  ASTForLoop jjtn000 = new ASTForLoop(JJTFORLOOP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ForLoop */
  try {
/*@egen*/
  < FOR > Identifier() < EQUAL > Expression() < TO > Expression() ( < STEP > Expression() ) ? < NL >
    ListOfInstructions()
  < NEXT >/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}


void SubCall() :
{/*@bgen(jjtree) SubCall */
  ASTSubCall jjtn000 = new ASTSubCall(JJTSUBCALL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) SubCall */
  try {
/*@egen*/
  < CALL > Identifier() "(" ParameterList() ")"/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void ParameterList()       :
{}
{
  (
  Expression() ( "," Expression() )*
  )?
}

void SubDef() :
{/*@bgen(jjtree) SubDef */
  ASTSubDef jjtn000 = new ASTSubDef(JJTSUBDEF);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) SubDef */
  try {
/*@egen*/
  < SUBROUTINE > Identifier() < NL >
    ListOfInstructions()
  < RETURN >/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Print() :
{/*@bgen(jjtree) Print */
  ASTPrint jjtn000 = new ASTPrint(JJTPRINT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Print */
  try {
/*@egen*/
  < PRINT > Expression()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/ 
}

void Declaration() :
{/*@bgen(jjtree) Declaration */
  ASTDeclaration jjtn000 = new ASTDeclaration(JJTDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Declaration */
  try {
/*@egen*/
  < DIM > Identifier() < AS > < INTEGER >/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Assignment() :
{/*@bgen(jjtree) Assignment */
  ASTAssignment jjtn000 = new ASTAssignment(JJTASSIGNMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Assignment */
   try {
/*@egen*/
   < LET > Identifier() < EQUAL >  Expression()/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

/* ----------------------- */

void Expression()       ://#Expression(>1) :
{}
{
  ConcatExpression() {}
}

void ConcatExpression()                       :
{/*@bgen(jjtree) #ConcatExpression(> 1) */
ASTConcatExpression jjtn000 = new ASTConcatExpression(JJTCONCATEXPRESSION);
boolean jjtc000 = true;
jjtree.openNodeScope(jjtn000);
/*@egen*/
Token t;
}
{/*@bgen(jjtree) #ConcatExpression(> 1) */
  try {
/*@egen*/
  StringExpression()
  (
    t = < CONCAT > { jjtn000.value = t.image; }
    
    StringExpression()
  )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
  }
/*@egen*/
}

void StringExpression()       :
{}
{
  BooleanExpression() | StringLiteral()
}

void StringLiteral() :
{/*@bgen(jjtree) StringLiteral */
  ASTStringLiteral jjtn000 = new ASTStringLiteral(JJTSTRINGLITERAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) StringLiteral */
  try {
/*@egen*/
  t = < STRING_LITERAL >/*@bgen(jjtree)*/
                         {
                           jjtree.closeNodeScope(jjtn000, true);
                           jjtc000 = false;
                         }
/*@egen*/ { jjtn000.value = t.image; }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void BooleanExpression()                        :
{/*@bgen(jjtree) #BooleanExpression(> 1) */
  ASTBooleanExpression jjtn000 = new ASTBooleanExpression(JJTBOOLEANEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) #BooleanExpression(> 1) */
  try {
/*@egen*/
  EqualityExpression()
  (
    t = < BOOL_OP > { jjtn000.value = t.image; }
    
    EqualityExpression()
  )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
  }
/*@egen*/
}

void EqualityExpression()                         :
{/*@bgen(jjtree) #EqualityExpression(> 1) */
  ASTEqualityExpression jjtn000 = new ASTEqualityExpression(JJTEQUALITYEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) #EqualityExpression(> 1) */
  try {
/*@egen*/
  RelationalExpression()
  (
    t = < EQ_OP > { jjtn000.value = t.image; }
    
    RelationalExpression()
  )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
  }
/*@egen*/
}

void RelationalExpression()                           :
{/*@bgen(jjtree) #RelationalExpression(> 1) */
  ASTRelationalExpression jjtn000 = new ASTRelationalExpression(JJTRELATIONALEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) #RelationalExpression(> 1) */
  try {
/*@egen*/
  AdditiveExpression()
  (
    t = < REL_OP > { jjtn000.value = t.image; }
    
    AdditiveExpression()
  )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
  }
/*@egen*/
}

void AdditiveExpression()                         :
{/*@bgen(jjtree) #AdditiveExpression(> 1) */
  ASTAdditiveExpression jjtn000 = new ASTAdditiveExpression(JJTADDITIVEEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Node n; 
  Token t;
  String op = "err";
}
{/*@bgen(jjtree) #AdditiveExpression(> 1) */
  try {
/*@egen*/
  MultiplicativeExpression()
  
  ( 
    t = < ADD_OP > { op = t.image; }		// Store the operation.
    
    MultiplicativeExpression()
    {
      /* This code is key to imitating the left recursiveness that expressions
         exibit, but JavaCC disallows us from using.
       */
      ASTAdditiveExpression newN = new ASTAdditiveExpression(bc1TreeConstants.JJTADDITIVEEXPRESSION);
      newN.value = op;
      
      // Pop and add the first operand from the stack
      n = jjtree.popNode();
      newN.jjtAddChild(n, 1);
      n.jjtSetParent(newN);
      
      // Pop and add the second operand from the stack
      n = jjtree.popNode();
      newN.jjtAddChild(n, 0);
      n.jjtSetParent(newN);
      
      // Push the new node back on the stack
      jjtree.pushNode(newN);
    }
  )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
  }
/*@egen*/
  
}

void MultiplicativeExpression()                               :
{/*@bgen(jjtree) #MultiplicativeExpression(> 1) */
  ASTMultiplicativeExpression jjtn000 = new ASTMultiplicativeExpression(JJTMULTIPLICATIVEEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Node n; 
  Token t;
  String op = "err";
}
{/*@bgen(jjtree) #MultiplicativeExpression(> 1) */
  try {
/*@egen*/
  UnaryExpression()
  (
    t = < MUL_OP > { op = t.image; }
    
    UnaryExpression()
    {
      /* This code is key to imitating the left recursiveness that expressions
         exibit, but JavaCC disallows us from using.
       */
      ASTMultiplicativeExpression newN = new ASTMultiplicativeExpression(bc1TreeConstants.JJTMULTIPLICATIVEEXPRESSION);
      newN.value = op;
      
      // Pop and add the first operand from the stack
      n = jjtree.popNode();
      newN.jjtAddChild(n, 1);
      n.jjtSetParent(newN);
      
      // Pop and add the second operand from the stack
      n = jjtree.popNode();
      newN.jjtAddChild(n, 0);
      n.jjtSetParent(newN);
      
      // Push the new node back on the stack
      jjtree.pushNode(newN);
    }
  )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
  }
/*@egen*/
  
}

void UnaryExpression()       :
{}
{
  "(" Expression() ")"
| UnaryPlusOrMinus()
| Identifier()
| Integer()
}

void UnaryPlusOrMinus()                  :
{/*@bgen(jjtree) UnaryExpression */
ASTUnaryExpression jjtn000 = new ASTUnaryExpression(JJTUNARYEXPRESSION);
boolean jjtc000 = true;
jjtree.openNodeScope(jjtn000);
/*@egen*/
Token t;
}
{/*@bgen(jjtree) UnaryExpression */
   try {
/*@egen*/
   t = < ADD_OP > { jjtn000.value = t.image; } UnaryExpression()/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/ 
}

void Identifier() :
{/*@bgen(jjtree) Identifier */
  ASTIdentifier jjtn000 = new ASTIdentifier(JJTIDENTIFIER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) Identifier */
  try {
/*@egen*/
  t = < IDENTIFIER >/*@bgen(jjtree)*/
                     {
                       jjtree.closeNodeScope(jjtn000, true);
                       jjtc000 = false;
                     }
/*@egen*/ { jjtn000.value = t.image.toLowerCase(); }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Integer()                 :
{/*@bgen(jjtree) IntegerLiteral */
  ASTIntegerLiteral jjtn000 = new ASTIntegerLiteral(JJTINTEGERLITERAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) IntegerLiteral */
  try {
/*@egen*/
  t = < INTEGER_LITERAL >/*@bgen(jjtree)*/
                          {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtc000 = false;
                          }
/*@egen*/ { jjtn000.value = t.image; }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}
